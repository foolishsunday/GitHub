#<center> .net/C#/.net core笔记< /center>
#一 语法
##1.命名： 
	Fetch/Download比get好
	建议使用的单词： 
	send/deliver/dispatch/announce(宣布)/distribute(分配)/route(路由)
	find/search/extract(抽出)/locate/recover
	start/launch/create/begin/open
	make/create/setup/build/generate/compose
	add/new
	args/seq/arr/list/registers/text/item
	hasMore/hasNext
	使用具体的名字来描述：ServerCanStart()比CanListenOnPort好
	给变量带上重要细节：表示毫秒_ms，表示未处理raw_
	if(不断变化的值 < 固定值)
	ConditionalAttribute 代替#if #endif
##2.Limq本质：Lambda表达式和扩展方法。
			Lambda表达式本质：匿名方法。
			扩展方法：由参数调用方法，不用声明对象，因为类和方法都是静态的。
##3.集合类的选用：
	HashSet：不重复
	SortedSet:排序且不重复
	Queue:先入先出
	Stack：后入先出
	Hashtable:哈希表键值对，不支持泛型，多线程推荐使用
	LinkedList:频繁插入或删除，把XX元素移到第XX位时
	SortedList:排序；排好序的键值对，查找数据极快，但添加新元素，删除元素较慢	
	Dictionary:不排序；通过键来检索值的速度快，接近于 O(1)，支持泛型，单线程使用
	SortedDictionary:排序；查找，添加，删除速度都比较平均
##4.IOC：
	1.解耦 2.屏蔽细节。DI依赖注入，是实现IOC的手段。DI：构造对象，能自动把依赖的对象生成并传入，支持递归无限级的。 IOC是目标，DI是手段。
##5.默认字段：
	初始化优于赋值语句：值类型初始化为0，引用类型初始化为null
##6.非托管资源与非托管资源
	非托管资源：I/O流，数据库连接，Socket连接，窗口句柄 -- 人工控制
	托管资源：“对象在堆中的内存”
##7.泛型的类型参数约束
	- where T : struct 		| T必须是一个结构类型
	- where T : class  		| T必须是一个class类型
	- where T : new()  		| T必须有一个无参构造函数
  	- where T : BaseService 	| T 必须继承了BaseService
    - where T : IService		| T必须实现IService 
##8.为什么要自定义异常类
	a.没有具体系统异常相对应
	b.不希望再catch块中处理
	c.希望明确标识出错误种类的异常
##9.快捷产生字符
产生8个'#'
`new string('#', 8)`

产生1到10个数字
`new List<int>(Enumerable.Range(1, 10))`

#二 .net core
##.net core生命周期：
	AddTransient ：瞬时生命周期，每次请求 Transient 生命周期服务时都会创建它们。此生命周期最适合轻量级、无状态的服务。
	AddSingleton：单例，创建服务类的单个实例，将其存储在内存中，并在整个应用程序中重复使用。我们可以将 Singleton 用于实例化成本昂贵的服务
	AddScoped：作用域单例，一个请求一个实例。
	每个请求会创建一次服务实例。参与处理单个请求的所有中间件、MVC 控制器等等，都将获得相同的实例。实体框架上下文（Entity Framework context）是使用 Scoped 服务的一个很好的场景。
	没有线程单例，不建议太多单例，多个线程对单例操作，线程不安全。
	适合单例：配置文件、容器实例、连接池、线程池
	大部分是瞬时生命周期
##6.AOP异常：
	三种方法：1.直接用特性 2.用内置的ServiceFilter 3.全局注册AddControllersWithViews

####什么时候用Scope？
	请求单例：一次Http请求就是一个实例，一次请求创建一个容器实例
##浏览器向服务器请求的数据有：
	1. QueryString字符串
	2. Form
	3. Cookie
	4. Session
	5. Header
##Get/Put/Post/Delete
	
	get：数据获取 | put:数据的插入 | post:数据更新 | delete:数据删除 

##用swagger时，必须有访问方式
##EntityFrameworkCore安装包：
	Microsoft.EntityFrameworkCore
	Microsoft.EntityFrameworkCore.SqlServer
	Microsoft.EntityFrameworkCore.Tools
	Pomelo.EntityFrameworkCore.MySql
###DbFirst
	设为启动项目->程序包管理控制台->默认项目->输入(MySql):  Scaffold-DbContext -Force -OutputDir Entity -ContextDir Context -Context CimdbContext  "server=127.0.0.1;user id=root;database=cimdb;password=itc123!@#" -Provider "Pomelo.EntityFrameworkCore.MySql"
---
命令参数|作用
---|---|
OutputDir|实体文件所存放的文件目录
ContextDir|DbContext文件存放的目录
Context|DbContext文件名
Schemas|需要生成实体数据的数据表所在模式
Tables|需要生成实体数据的数据表的集合
UseDatabaseNames|直接使用数据库中的表名和列名（某些版本不支持）
Force|强制执行，重写已经存在的实体文件

###Code First

/|/|
--|--|	
[AllowAnonymous]|跳过授权校验

###Token校验
	User <---> Authorization(返回Token) 
	User <---> Api(带着Token访问)
	User <---> Third Party(带着Token访问，第三方Api)

	Token的有效性，通过加密解密完成

###微服务架构
	SOA：总线，中介者模式
	微服务：门面模式

####进程间通信
/|/|
--|--|	
1.共享存储|Redis，DB，Queue，硬盘文件
2.服务通信|WebService，WCF，WebApi，ashx/aspx
3.RPC|.Net平台独有

###鉴权授权
第一步：在app.UseRouting()之后、app.UseEndpoints之前增加鉴权授权；
/|/|
--|--|
鉴权|检测用户是否登录
授权|检测有没有权限，是否能访问后续的页面功能

第二步：在ConfigureServices中增加
第三步：指定哪些Action需要做鉴权授权[Authorize]
####鉴权授权 identity server4与.net core融合比较好
User (登录请求)-> Authorization
              <- 返回token
			  Gateway识别并解析token 
即由identity server4发放token带到httpcontext中，由Gatewa识别解析token
###角色授权
	不同的用户不同角色，做不同拦截。

####集群
	服务实例必须集群/负载均衡：多台服务器做相同的事，共同承载压力（高可用，可伸缩）（比如应对服务器挂了）
	Nginx：单纯是负载均衡，不够用
	1.增加/减少服务实例,动态增减,要重启Nginx，服务注册与发现不智能
	2.健康检查（微服务实例代码小于2000行）,如遇到网络断网，即时发现问题，下线
####Consul
	服务启动时注册-Consul-调用者调用
	|_______Health check______|
####网关Gateway
	作用：更换ip、端口、更新程序时
	1.提供统一服务入口
	2.聚合后台服务，节省流量，提升性能
	3.提供安全，过滤，流控等API管理功能

	服务治理：
	缓存：共享缓存
	熔断：服务挂了，请求还不断，即时通知。单位时间内异常多少次，网关返回失败
	限流：单位时间内流量只允许多少次，多了排队
	降级：特殊情况，可以降低服务等级，甚至关闭
####瞬态故障处理 Polly(调用失败，重试)
	一种.NET弹性和瞬态故障处理库，允许以非常顺畅和线程安全的方式来执行重试、短路、超时、故障恢复等策略

####分布式追踪Skywalking Skyapm-首选
	分布式追踪和APM的server端，它将包含Collector，Storage，独立的WebUI，并使用OpenTracing规范来设计追踪数据（分配一个Guid,统计在各个环节流程的信息）
####Exceptionless-首选
	开源的日志收集和分析框架，能为应用程序提供实时错误、特性和日志报告
####Apollo统一配置中心-首屈一指
	Apollo：配置管理平台，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。（集中的配置中心，不同集群不同环境可以配置推送）
####分布式事务
	CAP，分布式锁
	任何分布式系统只可同时满足C一致性、A可用性、P分区容错性中的两点，没法三者兼顾。满足可用性、最终一致性。实现最终一致性三种模式：
	1.可靠事件模式 2.业务补偿模式 3.TCC模式
####容器化
	docker：实质是进程，里面是沙箱（包含环境和程序）。快速启动实例
	K8S容器编排：把容器当资源，说明书，管理docker进程、资源、docker的关系。docker是宿舍，K8S是宿舍阿姨
####CI/CD 持续集成持续发布
	Jenkins：开源的、提供友好操作界面的持续继承工具，主要用于持续、自动的构建/测试软件项目、监控外部任务的运行。（提交代码后，构建测试、发布）


####启动微服务命令
dotnet BBSWeb.dll --urls="http://*:5002" --ip="127.0.0.1"--port=5002
####分布式
一个进程做的事，分成多个进程协作完成
####集群和服务注册发现
string url = "http://localhost:5000/aip/user/all"
string content = InvokeApi(url);

        public static string InvokeApi(string url)
        {
            using (HttpClient httpClient = new HttpClient())
            {
                HttpRequestMessage message = new HttpRequestMessage();
                message.Method = HttpMethod.Get;
                message.RequestUri = new Uri(url);
                var result = httpClient.SendAsync(message).Result;
                string content = result.Content.ReadAsStringAsync().Result;
                return content;
            }
        }
集群：多个完全相同的实例，共同完成一件事。每个实例完全一样。一台服务器做的事，现在由多台服务器共同承载，每台服务器都是独立完成。
分布式：多台服务器完成一台服务器的事，每台服务器完成步骤，串行完成全部任务。

JWT结构：
{"alg":"HS256", "typ":"JWT"}

payload 有效载荷
JWT默认是不加密的，任何人都可读取

Signature 签名-防止抵赖-防止篡改

####如何应对大数据高并发

/|/|/|/|/|/|/|
--|--|--|--|--|--|--|--|--|--|--|--|	
集群|队列|分布式|Redis/缓存|读写分离|MQ|K8S负载均衡

吞吐量QPS：单位事件内能处理多少个请求
第一步：首选使用缓存--降低数据库压力

负载均衡服务器(LVS/Nginx/HAProxy)->应用服务器
DNS也可以做负载均衡：高效--就近原则（就近分配访问的服务器），只能轮询，独立IP很贵，无法做到错误发现

1.单机系统：升级硬件
2.独立服务器：分布式
3.缓存
4.集群负载均衡:Nginx、硬件负载均衡、DNS负载均衡、软件负载均衡LVS、HAProxy

	Nginx策略：轮询--weight--ip hash--fair--url hash
	用户持久化：
	ip hash--会话粘滞，局限性很强
	Session共享--Inproc/StateServe--Redis基于HttpHeader--Cookie--Token(JWT/IdentityServer4)

5.读写分离：

	一主多从：发布订阅
	数据库负载均衡：基于中间层Moebius完成负载均衡
	即一样的库、一样的数据、一样的增删改，中间层moebius做协调同步分发
垂直分表
水平分表
分库分表分区

6.反向代理&CDN：继续使用缓存

各级都有缓存

	浏览器(客户端缓存)--DNS--反向代理--服务器（分布式缓存）--DB

7.分布式文件系统：把多个网络硬盘管理成本地的
8.专项突破
场景1：全文搜素
Lucene--Solr--ES
利用全文检索技术，分词建索引，拆词存储起来，搜索时也分词
场景2：秒杀系统：解决超卖问题
	
	a.基于数据库的锁--悲观锁，无法满足高并发
	b.乐观锁--加一个version字段，先查一下版本号，在update，且version+1。多个并发只有一个成功
	c.限流：限制请求到达数据库
	  防超卖：
	  性能高：
	  Redis 远程字典服务器 内存快速读写
	  单线程模型
	  限流 incr(+1返回余额) decr(-1返回余额)：原子性防止超卖
	d.分布式锁
	e.队列
场景3：刷榜